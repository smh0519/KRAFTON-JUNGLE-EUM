# 0101 화이트보드 제안서

# 화이트보드 시스템 기술 분석 및 고도화 제안서

> 문서 정보
> 
> - **작성일**: 2026년 01월 01일
> - **대상 모듈**: Frontend (Next.js/PIXI.js), Backend (Go/Fiber/GORM)

## 1. Executive Summary

본 문서는 현재 구현된 화이트보드 시스템의 로직을 심층 분석하여

**성능 저하 및 데이터 무결성 문제**를 진단하고, 이를 해결하기 위한 **구체적인 기술 구현 방안**을 제시합니다.

현재 구조는 프로토타입 단계에서는 정상 작동하나, 사용량이 증가함에 따라 **서비스 불능 상태**에 이를 수 있는 치명적인 병목 구간이 존재합니다.

따라서 본 문서에서 제안하는 **DB 정규화 및 로직 개선**이 서비스 배포 전 필수적으로 선행되어야 합니다.

---

## 2. Critical Bottlenecks

### 1) Backend : O(N) 저장 구조 [가장 심각]

- **현상** : 사용자가 획을 하나 그릴 때마다 백엔드는`DB 읽기` → `전체 JSON 파싱` → `배열 추가` → `전체 JSON 직렬화` → `DB 덮어쓰기`를 수행합니다.
- **Time Complexity** : **O(N)** (N = 누적된 획의 총 데이터 크기)
- **예상 시나리오**:
    - 회의 시작 10분 (데이터 1MB) : 획 1개 추가 시 1MB 처리
    - 회의 시작 1시간 (데이터 10MB) : 획 1개 추가 시 **10MB 처리** (급격한 속도 저하)
- **위험도** : 최상 (서비스 중단 가능성 높음)

### 2) Data Integrity : Race Condition

- **현상** : 두 명의 유저(A, B)가 동시에 그리기를 종료하여 거의 동시에 저장 요청을 보내는 경우
- **문제** : A와 B가 읽어온 시점의 데이터가 동일합니다. 먼저 저장을 끝낸 사람의 데이터는 나중에 저장을 끝낸 사람의 Overwrite로 인해 **완전히 소멸**됩니다.
- **위험도** : 최상 (데이터 유실 확정적)

### 3) Network : Packet Flood

- **현상** : 마우스가 움직일 때마다(`pointermove`) 즉시 이벤트를 전송합니다.
- **문제** : 초당 수십~수백 개의 작은 패킷이 발생하여 네트워크 대역폭보다는 **패킷 처리 오버헤드**로 인한 지연을 유발합니다.
- **위험도**: 중간 (사용자 경험 저하)

### 4) Frontend : Object Explosion

- **현상**: PIXI.js에서 획 하나당 별도의 `Graphics` 객체를 생성합니다.
- **문제**: 장시간 회의 시 수만 개의 객체가 메모리에 쌓이며 렌더링 프레임 드랍이 발생합니다.

---

## 3. Metrics

### 3.1 시간 복잡도 비교

| **작업** | **현재 로직**  | **개선 시**  | **비고** |
| --- | --- | --- | --- |
| **획 저장**  | **O(N)** | **O(1)** | 가장 시급한 개선 대상 |
| **초기 로딩**  | O(N) | O(N) | 데이터 양에 비례 (필연적) |
| **되돌리기**  | **O(N)** | **O(1**) | 현재 구조에선 전체 재저장 필요 |

### 3.2 리소스 사용량 추정

*가정: 4인 회의, 1시간 진행, 활발한 사용 시*

- **총 데이터 크기** : 약 5MB ~ 10MB 예상
- **Backend 부하** :
    - 데이터가 10MB일 때 유저가 점 하나만 찍어도 **10MB Read + 10MB Write** 트랜잭션 발생
    - 4명이 동시에 그릴 경우 초당 수백 MB의 불필요한 I/O 발생 → **DB CPU 100% 도달**

---

## 4. Solutions

위에서 식별된 병목 현상을 해결하기 위한 구체적인 기술 구현 방안입니다.

### 4.1 Backend : Normalization

**목표**: O(N)의 저장 복잡도를 **O(1)**로 단축하고, **동시성 데이터 유실** 문제를 근본적으로 해결합니다.

**① 데이터베이스 스키마 설계**

기존 `Whiteboards` 테이블(통짜 JSON)은 백업 용도로만 유지하고, 실시간 데이터는 신규 테이블로 분리합니다.

```sql
-- 획(Stroke) 단위 저장을 위한 신규 테이블
CREATE TABLE whiteboard_strokes (
    id          BIGINT AUTO_INCREMENT PRIMARY KEY,
    meeting_id  BIGINT NOT NULL,
    user_id     BIGINT NOT NULL,      -- 작성자 식별
    stroke_data JSON NOT NULL,        -- 획 하나의 좌표 배열 (Point[])
    layer       INT DEFAULT 0,        -- 겹침 순서 (Z-index)
    is_deleted  BOOLEAN DEFAULT FALSE,-- 지우개 사용 시 Soft Delete 처리
    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_meeting_order (meeting_id, id) -- 조회 성능 최적화
);
```

**② API 로직 변경안**

- **POST /api/whiteboard (저장)**
    - **AS-IS**: `UPDATE whiteboards SET data = ?` (전체 덮어쓰기)
    - **TO-BE**: `INSERT INTO whiteboard_strokes ...` (단순 추가)
    - **Result**: 데이터 누적량과 무관하게 항상 일정하고 빠른 속도 보장 (Lock 불필요).
- **Undo/Redo**
    - **TO-BE**: 사용자의 마지막 `stroke`를 찾아 `UPDATE ... SET is_deleted = TRUE` (Soft Delete) 처리.

### 4.2 Network : Event Batching

**목표**: 네트워크 패킷 수를 90% 이상 감소시켜 **서버 및 클라이언트 CPU 부하**를 최소화합니다.

**구현 방안 (Throttle & Buffer)**

```tsx
// AS-IS: 움직일 때마다 즉시 전송 (비효율적)
function onPointerMove(e) {
  socket.emit('draw', { x, y }); 
}

// TO-BE: 모아서 전송 (Batching)

let pointBuffer = [];

// 1. 입력 수집

function onPointerMove(e) {
  pointBuffer.push({ x, y }); 
}

// 2. 50ms마다 묶어서 전송 (초당 20회 고정)

setInterval(() => {
  if (pointBuffer.length > 0) {
    socket.emit('draw_batch', pointBuffer);
    pointBuffer = [];
  }
}, 50);
```

### 4.3 Frontend : Rendering Optimization

**목표**: 장시간 사용 시 메모리 누수 방지 및 렌더링 프레임 드랍 제거.

**구현 방안**

1. **Current Stroke** : 그리는 중인 획은 임시 `Graphics` 객체 사용.
2. **Completed Strokes** : 완료된 획은 하나의 거대한 'Main Graphics' 객체에 Merge.
3. **Bitmap Caching** : 획이 일정 개수 쌓일 때마다 이를 하나의 Texture로 구워버림으로써 GPU 부하를 최소화.

---

## 5. 단계별 적용 로드맵

| **단계** | **구분** | **작업 내용** | **예상 소요시간** |
| --- | --- | --- | --- |
| **Phase 1** | **Backend (긴급)** | DB 스키마 생성, API Insert/Select 로직 변경 | 1~2일 |
| **Phase 2** | **Network** | Frontend 배칭 로직 추가, Backend 배칭 수신 처리 | 0.5일 |
| **Phase 3** | **Frontend** | PIXI.js 렌더링 최적화 (Bitmap Caching) | 1~2일 |

---

## 6. Conclusion

현재 시스템은 **기능 구현** 측면에서는 완성되어 있으나, 확장성과 **안정성** 측면에서 중대한 결함이 확인되었습니다.

특히 백엔드의 '전체 덮어쓰기' 저장 방식은 다중 사용자 환경에서 데이터 유실을 필연적으로 동반합니다. 따라서 **Phase 1 (Backend 정규화)** 작업은 선택이 아닌 서비스 배포를 위한 **필수 전제 조건**입니다.